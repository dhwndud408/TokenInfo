{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"F:\\\\SynologyDrive\\\\Code\\\\Ethereum Smart Contract\\\\TokenInfoWeb\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\SynologyDrive\\\\Code\\\\Ethereum Smart Contract\\\\TokenInfoWeb\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { ec as EC } from \"elliptic\";\nimport { arrayify, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nvar _curve = null;\n\nfunction getCurve() {\n  if (!_curve) {\n    _curve = new EC(\"secp256k1\");\n  }\n\n  return _curve;\n}\n\nexport var SigningKey = /*#__PURE__*/function () {\n  function SigningKey(privateKey) {\n    _classCallCheck(this, SigningKey);\n\n    defineReadOnly(this, \"curve\", \"secp256k1\");\n    defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n    var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n    defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n    defineReadOnly(this, \"_isSigningKey\", true);\n  }\n\n  _createClass(SigningKey, [{\n    key: \"_addPoint\",\n    value: function _addPoint(other) {\n      var p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n      var p1 = getCurve().keyFromPublic(arrayify(other));\n      return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n  }, {\n    key: \"signDigest\",\n    value: function signDigest(digest) {\n      var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n      var signature = keyPair.sign(arrayify(digest), {\n        canonical: true\n      });\n      return splitSignature({\n        recoveryParam: signature.recoveryParam,\n        r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n        s: hexZeroPad(\"0x\" + signature.s.toString(16), 32)\n      });\n    }\n  }, {\n    key: \"computeSharedSecret\",\n    value: function computeSharedSecret(otherKey) {\n      var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n      var otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n      return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n  }], [{\n    key: \"isSigningKey\",\n    value: function isSigningKey(value) {\n      return !!(value && value._isSigningKey);\n    }\n  }]);\n\n  return SigningKey;\n}();\nexport function recoverPublicKey(digest, signature) {\n  var sig = splitSignature(signature);\n  var rs = {\n    r: arrayify(sig.r),\n    s: arrayify(sig.s)\n  };\n  return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n  var bytes = arrayify(key);\n\n  if (bytes.length === 32) {\n    var signingKey = new SigningKey(bytes);\n\n    if (compressed) {\n      return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n    }\n\n    return signingKey.publicKey;\n  } else if (bytes.length === 33) {\n    if (compressed) {\n      return hexlify(bytes);\n    }\n\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n  } else if (bytes.length === 65) {\n    if (!compressed) {\n      return hexlify(bytes);\n    }\n\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n  }\n\n  return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}","map":{"version":3,"sources":["F:/SynologyDrive/Code/Ethereum Smart Contract/TokenInfoWeb/node_modules/@ethersproject/signing-key/lib.esm/index.js"],"names":["ec","EC","arrayify","hexlify","hexZeroPad","splitSignature","defineReadOnly","Logger","version","logger","_curve","getCurve","SigningKey","privateKey","keyPair","keyFromPrivate","getPublic","other","p0","keyFromPublic","publicKey","p1","pub","add","encodeCompressed","digest","signature","sign","canonical","recoveryParam","r","toString","s","otherKey","otherKeyPair","computePublicKey","derive","value","_isSigningKey","recoverPublicKey","sig","rs","recoverPubKey","encode","key","compressed","bytes","length","signingKey","throwArgumentError"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { ec as EC } from \"elliptic\";\nimport { arrayify, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\nexport class SigningKey {\n    constructor(privateKey) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 = getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const signature = keyPair.sign(arrayify(digest), { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nexport function recoverPublicKey(digest, signature) {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n    const bytes = arrayify(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n"]},"metadata":{},"sourceType":"module"}